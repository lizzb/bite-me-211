//
//  File.cpp
//  Lab 5 Due 22414 SGZ
//
//  Created by Sydney Zink on 2/23/14.
//  Copyright (c) 2014 Sydney Zink. All rights reserved.
//

#include "cvariable.h"

ostream& operator<<(ostream& out, CVariable& cvar)
{
    out<<"NAME:"<<cvar.name<<" VALUE:";
    out << cvar.value;
    return out;
}
ostream& operator<<(ostream& out, CVarDB& cdb)
{
    
    //cout << cdb;
    //do for loop to go through every element in the database
    for (int i = 0; i < sizeof(cdb); i++)
    {
        out << "name:" << ((cdb.db).at(i)).getName() << "value:";
        out << ((cdb.db).at(i)).Value();
    }
    return out;
}

CVariable::CVariable(const char* init_name)
{
    name = new char(strlen(init_name)+1);
    name = strcpy(name, init_name); // copy name into m_sName
    this->value = 0;
}

CVariable::CVariable(const char* init_name, double init_value)
{
    name = new char(strlen(init_name)+1);
    name = strcpy(name, init_name);
    this->value = init_value;
    /*
     cout<<"char array is size:"<<strlen(init_name)+1<<endl;
     for(int i=0;i<strlen(init_name)+1;i++)
     {
     //cout<<(int)(name[i])<<" ";
     
     if(name[i]=='\0')
     cout<<"\\0";
     else
     cout<<name[i];
     
     }
     cout<<endl;
     */
}

CVariable::CVariable(const CVariable& copy)
{
    CVariable m = copy;
    this->name=new char(strlen(copy.name)+1);
    int i=0;
    for(i=0;i<strlen(copy.name)+1;i++) //deep copy
    {
        this->name[i] = copy.name[i];
    }
    //this->name=copy.name;  //shallow copy, wrong
    this->value = copy.value; //okay b/c a single value
}

double& CVariable::operator*()
{
    return this->Value();
}

double CVariable::operator*() const
{
    return this->Value();
}

CVariable& CVariable::operator=(double newValue)
{
    
    this->value = newValue;
    return *this;
}

CVariable& CVariable::operator=(CVariable& newValue)
{
    //CVariable tmp(newValue);
    //swap(tmp);
    this->name = new char(strlen(newValue.getName())+1);
    int i=0;
    for(i=0;i<strlen(newValue.getName())+1;i++)  //deep copy
    {
        this->name[i]=newValue.getName()[i];
    }
    //this->name = newValue.getName();
    this->value = newValue.Value();
    return *this;
}

CVariable::~CVariable(){}

CVarDB::CVarDB()
{
    CVariable ans("ans", 0);
    db.push_back(ans);
}

bool CVarDB::add(CVariable& newVar) //FINISHED AND CORRECT, DO NOT TOUCH
{
    db.push_back(newVar);
    return 1;
}
/* CVariable* CVarDB::search(const char* name)
{
    // if(find(db.begin(), db.end(), name)!= db.end()){
        return CVariable*(name);
    }
    //if(cdb.search(lhs_value)!=-1)
    //Editing: cdb[cdb.search(lhs.name)].setValue(new_value);
    //else
    //Adding:cdb.add(lhs_name,value); //
    for(int i = 0; i < m_nSize; i++)
    {
        if(strcmp(db.at(i).getName(), name) == 0)
        {
            //Error: Can't covert CVariable to CVariable*
            return db.at(i);
        }
    }
    return NULL;
} */

