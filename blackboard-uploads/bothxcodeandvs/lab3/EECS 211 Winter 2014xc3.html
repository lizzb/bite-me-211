<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<!-- saved from url=(0133)https://courses.northwestern.edu/bbcswebdav/pid-4901637-dt-content-rid-13514177_1/courses/2014WI_EECS_211-0_SEC21/Lab%203%281%29.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
   <meta name="Generator" content="Microsoft Word 97">
   <meta name="Template" content="C:\Program Files\Microsoft Office\Office\html.dot">
   <meta name="GENERATOR" content="Mozilla/4.73 [en]C-{C-UDP; EBM-SONY1}  (Windows NT 5.0; U) [Netscape]">
   <title>EECS 211 Winter 2014</title>
</head>
<body link="#0000FF" vlink="#800080">
<b>EECS 211 Winter 2014</b>
<center>
<p><b><font size="+1">Lab 3:  a Command Line Interpreter</font></b>
</p><p><b>Due: Feb. 3rd, 11:59pm</b></p></center>

<p><b><font size="+1">Objective</font>:</b>
</p><p>Built on Lab 2, the goal of this lab is to write a command line interpreter.
This tool will partition a command line and perform a simple grammar check.
Through this lab, you will gain some experience on:
</p><p>[1] C/C++ control structures;
<br>[2] strings and arrays;
<br>[3] functions and modular design
<br>&nbsp;
</p><p><b><font size="+1">Problem Description</font></b>
</p><p> Lab 3 is built on Lab 2, in which you implemented a command line interpreter.
In addition to partitioning a command line into valid segments as you did in
Lab 2, you will do the following in Lab 3:
</p><blockquote>
<li>Read command lines from file 'TestCase.txt'</li>
<li>Interpret the command</li>
<li>
  Resolve a command line by checking the grammar of the command</li>

<li>
"Explain" the command line (sample output shown in Output.jpg)</li>

<li>
Continue interpreting commands until the "quit" command is encountered</li>
</blockquote>
This program allows for only 5 other valid types of commands:
<ol>
<li>
Assignment:&nbsp;&nbsp; "variable_1&nbsp;&nbsp; =&nbsp;&nbsp; operand_1",
e.g., a = 1</li>

<li>
Unary operation:&nbsp;&nbsp;&nbsp; "variable_1&nbsp;&nbsp;&nbsp; operator",
e.g., a++</li>

<li>
Assignment and binary operation:&nbsp; "variable = operand_1&nbsp;&nbsp;&nbsp;&nbsp;
operator&nbsp;&nbsp;&nbsp; operand_2", e.g., a = b + c</li>
<li>
Binary operation:&nbsp;&nbsp; "operand_1&nbsp;&nbsp;&nbsp; operator&nbsp;&nbsp;&nbsp;
operand_2", e.g., a + b, which  assigns the result to a default variable 'ans'.  Note that this statement has the same effect as prefixing the command with "ans =", so you may treat these as variations on the same command type.</li>

<li>Assignment with multiple operations or more than two operands are not valid: "variable = operand_1&nbsp;&nbsp;&nbsp;&nbsp;
operator&nbsp;&nbsp;&nbsp; operand_2 operator operand_3", e.g., a = b + c - d</li>
<li>Valid operators: +, -, * , \, ++, --, and =. All other operators, even +=, -=, *=, and \= are not valid.</li>
<li>In the statements above, "operands" can be replaced by variable or numeric values.
</li></ol>
The only valid commands for this program are 'assignment', 'binary operation', 'unary operation' and 'assignment and binary operation' as valid command line, and treat all the other commands as invalid. If a command line is invalid, detect it and printout an error message, such as "Sorry, I don't understand!".
<p>To do this, you may want to define "operation" and "operation type" as an enumerated type:  
</p><pre>enum OP {ASSIGN, ADD, SUB, MULT, DIV, INC, DEC};

enum OP_TYPE {ASSIGN_T, UNARY_T, BINARY_T, ASSIGN_BINARY_T};</pre>
Then all your implementation can be based on  these two data types.
<p>You should design your program in modules. An individual function should
fulfill a specific task like a black box. <!--To use a function call, the calling function only needs to know the input(s) of the function call, and  the output the called function will return.--> 
</p><p>To give you some ideas, I will list some function prototypes you may want to   consider and implement. </p>
<p>Of course, you may  implement your solution in your own way. </p>
<pre>
// NOTE:
// functions related to the command line interpreter
// resolve a statement into 5 parameters, including: (1) result_name, (2) operand_1_name,&nbsp;
// (3) operand_2_name, (4) operator and (5) type
</pre>
<pre>// This interpret() function is the most important part of MP#3
// functionality: Resolve a statement (symbolic) into operator and operands
// input:&nbsp; char* state (suppose it IS a statement)
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; We only allow: type ASSIGN_T:&nbsp;&nbsp; e.g., a = b
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type UNARY_T: e.g., a++, --b,
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type BINARY_T:e.g., a + b
//
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type ASSIGN_BINARY_T c = a+b
// output (bool): whether an error occurred during interpretation&nbsp;&nbsp;
// Example:
// A command line: a = b + 1
// can be resloved as: operator -- ADD, type -- ASSIGN_BINARY_T, count = 5 (# of pieces)
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result_name -- "a", operand_1_name -- "b", operand_2_name -- "1"
//
bool&nbsp;&nbsp; interpret(const char* statement, char *res_name, OP&amp; op,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OP_TYPE&amp; type, char *operand_1_name, char *operand_2_name, int&amp; count);

// read a segment from buffer from position pIndex
int&nbsp;&nbsp;&nbsp; ReadAPiece(const char* buffer, int&amp; pIndex, char* piece);

// display an OP accordingly, i.e., show + as "ADD"
void&nbsp;&nbsp; TranslateOP(const OP op);

// understand a statement, i.e., print "ADD 1 AND a, THEN ASSIGN to b"
void&nbsp;&nbsp; UnderstandAStatement(const char* res_name, const OP op, const OP_TYPE type,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* operand_1_name, const char* operand_2_name);&nbsp;

// functions related to string manipulations
bool&nbsp;&nbsp; CompareString(const char* str1, const char* str2);
bool&nbsp;&nbsp; CopyString(const char* strFrom, char* strTo);</pre>

<p><br>
  A example of the running of the command line interpreter:
</p><pre>&gt;&gt; var_r = var_1 + 3.1415
&nbsp;&nbsp; ADD 3.1415 AND var_1, THEN ASSIGN to var_r

&gt;&gt; M_1 = [1 2 3; 3 4 5; 4 3 2] 
&nbsp;&nbsp; ASSIGN [1 2 3; 3 4 5; 4 3 2] to M_1

&gt;&gt; This MP is 4 fun 
&nbsp;&nbsp; Sorry, I don't understand

&gt;&gt; a ++ 
&nbsp;&nbsp; a INCREMENT

&gt;&gt; M_1 - 123 
&nbsp;&nbsp; SUB 123 FROM M_1, THEN ASSIGN TO ans&nbsp;

&gt;&gt; quit 
&nbsp;&nbsp; Thanks for using the command line interpreter!</pre>

<h3>
How to submit your work</h3>
Prepare this project in a single .cpp file. Name your program  "mp2.cpp" and upload  this file onto Blackboard.
<p>Don't forget    to make a copy of this file for yourself for future use. </p>
<h3> Grading</h3>
<p>25% Correct usage of C++ concepts <br>
  25% Visual appearance of the code <br>
  50% Correct functionality </p>
<p>

</p></body></html>