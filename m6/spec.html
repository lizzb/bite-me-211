<html>
<h3>Machine Problem Lab 6 Due: March 10, 11:59pm</h3>
  
  <hr/>
   Extended CMatrix class <br/>
  handle matrix addition and subtraction, scalar multiplication, and equality and inequality operators.
  <h3> cmatrix.h  </h3>
  
  
  <pre>

// Returns the result of adding two matrices;
// Result is a null matrix if input matrices are not the same size
CMatrix operator+(CMatrix& mat);

// Returns the result of subtracting one matrix from another;
// result is a null matrix if input matrices are not the same size
CMatrix operator-(CMatrix& mat);

// Returns the result of multiplying this matrix by another matrix;
// the result can be a null matrix if
// neither this nor the given matrix are 1x1
CMatrix operator*(CMatrix& mat);

// Returns the result of dividing this matrix by a scalar (1x1 matrix)
// result can be a null matrix if mat is not 1x1
CMatrix operator/(CMatrix& mat); 


// Returns true if the given CMatrix is the same size
// and contains all of the same values as this matrix
// (false otherwise) 
bool operator==(CMatrix& mat);


// Returns false if the given CMatrix is the same size
// and contains all of the same values as this matrix
// (true otherwise) 
bool operator!=(CMatrix& mat);

</pre>
  
    <hr/>
  
  <h3> cmatrix.cpp  </h3>
  <pre>
  
// Return result of adding two matrices
// null if input matrices are not the same size
CMatrix CMatrix::operator+(CMatrix& otherMatrix)
{
  // only matrices of the same size can be added/subtracted


  // if input matrices are not the same size,
  // result is a null matrix 
  return null;
}


// Returns result of subtracting one matrix from another
// null if input matrices are not the same size
CMatrix CMatrix::operator-(CMatrix& otherMatrix)
{
  // Can only add/subtract matrices of the same size
  //only matrices of the same size can be added/subtracted


  // if input matrices are not the same size,
  // result is a null matrix 
  return null;
}


// Return result of multiplying this matrix by a scalar
// null if neither matrix is a scalar (a 1x1 matrix)
CMatrix CMatrix::operator*(CMatrix& otherMatrix)
{
  return null;
}


// Return result of dividing this matrix by a scalar
// null if given matrix is not a scalar (a 1x1 matrix)
CMatrix CMatrix::operator/(CMatrix& otherMatrix)
{

  return null;
}


// Returns true if the given CMatrix is the same size
// and contains all of the same values as this matrix
// (false otherwise) 
bool CMatrix::operator==(CMatrix& otherMatrix)
{
  // check that matrices are same size first
  // if not, return false
  // check that every value is the same in each
  // if any value is not the same, return false
}


// Returns false if the given CMatrix is the same size
// and contains all of the same values as this matrix
// (true otherwise) 
bool CMatrix::operator!=(CMatrix& otherMatrix)
{
  // return the opposite of the == operator
}

  </pre>

   <hr/>
  
  <p>
    The choice of how you wish to represent scalar and matrix values inside a CVariable object may make certain operations simpler or more complex. One way to implement this idea in your code is to 
    <strong>
      change the value field of your CVariable class to have type CMatrix or CMatrix* rather than double, using "has-a" inheritance.
    </strong>
    
    </p>
  To allow CVariable to store and manipulate CMatrix values, you should add, replace, or modify the following member functions of CVariable:
  
  
      <hr/>
  
  <h3> cvariable.h  </h3>
    Extended CVariable class <br/>
able to store and manipulate matrix variables using the CMatrix class 
    
  
  <pre>
// Constructs a new CVariable with the given name that
// stores a copy of the given CMatrix (new constructor)
CVariable(const char* init_name, const CMatrix& init_value); 

// Sets the CMatrix stored in this CVariable to
// the given matrix and returns it (new function)
CMatrix& operator=(CMatrix& newValue); 


// Returns a reference to the CMatrix stored in this CVariable
// (replaces double& operator*())
CMatrix& operator*();


// Returns a copy of the CMatrix stored in a const CVariable 
// (replaces double operator*() const)
CMatrix operator*() const;



// Constructs a new CVariable to store a given scalar value
// as a 1x1 matrix (modification)
CVariable(const char* init_name, double init_value);



// Sets the CMatrix stored in this CVariable to a 
// given scalar value (1x1 matrix) and
// returns a reference to the stored matrix (modification)
CMatrix& operator=(double newValue); 

</pre>
  
  
   <hr/>
  
  <h3> cvariable.cpp  </h3>
    <pre>
// Constructs a new CVariable with the given name that
// stores a copy of the given CMatrix (new constructor)
CVariable::CVariable(const char* init_name, const CMatrix& init_value)
{


}


// Constructs a new CVariable to store a given scalar value
// as a 1x1 matrix (modification)
CVariable::CVariable(const char* init_name, double init_value)
{


}


// Set this CVariable's CMatrix to the given matrix and return it
CMatrix& CVariable::operator=(CMatrix& newValue)
{


}

// Set the CMatrix stored in this CVariable to a 
// given scalar value (1x1 matrix) and
// return a reference to the stored matrix (modification)
CMatrix& CVariable::operator=(double newValue)
{


}


// Returns a reference to the CMatrix stored in this CVariable
// (replaces double& operator*())
CMatrix& CVariable::operator*()
{


}


// Returns a copy of the CMatrix stored in a const CVariable 
// (replaces double operator*() const)
CMatrix CVariable::operator*() const
{


}




</pre>
  
  <hr/>
  
  
  <h3> main.cpp  </h3>
  <pre>

// main function
// read input test cases from "TestCases.txt"
// see expected output in "Output.jpg"

// Your submission should read test cases from the file "TestCase.txt".


// Update the code in the interpreter function
// (including any helper fx's like binary_assign_op and getValue)
// to operate in terms of CMatrices
// rather than double values !!


// Invalid matrix operations should result in an error message
// such as "Sorry, do not understand" or
// "Invalid operation, matrix size does not match."

// Example invalid matrix operations:
// (be sure to test each of these in your main function!)

// Adding together matrices of different sizes

// Dividing by a matrix (not scalar) value


</pre>
  
Machine Problem Lab 6: MiniMatlab 1.0
EECS 211 Winter 2014
Due: March 10, 11:59pm

  <hr/>
    
  <h3>
    How to submit your work
  </h3>
  
  <p>
    You should submit 5 files for this MP: 
    <li>cvariable.h</li>
    <li>cvariable.cpp</li>
    <em>which define the classes used to store and manipulate variables</em>
    <li>cmatrix.h</li>
    <li>cmatrix.cpp</li>
    <em>which define the CMatrix class</em>
    <li> main.cpp</li>
      <em>which is the parser and interpreter that run your MiniMatlab program.</em> <br/> <br/>


      Your submission should read test cases from the file "TestCase.txt".

  </p>
  <p>
    Ten points extra credit will be awarded if your solution is able to handle (non-scalar) matrix multiplication as well. For example, if the variables a and b are defined by a = [1 2; 3 4] and b = [5 9; 3 1], a * b should yield the output [11 11; 27 31 (not [5 18; 9 4]).
  </p>
    <p>
    Starting from your Lab 4 and Lab 5 solutions (or the provided code and sample solution), 
    <em>
      your MiniMatlab should be able to construct and manipulate matrix values and variables.
    </em>
  </p>
 

  
  <h3>
    Helpful hints
  </h3>
  
  <p>
    You may find it easiest to start by implementing the new CVariable functions and testing these with a separate main() function from your main MiniMatlab program.
  </p>
  
  <p>
    From there, you can incorporate the improved CVariables into your MiniMatlab modifying the getValue and assign_op functions to allow your program to handle assignment statements involving matrices (e.g., mat_1 = [1 2; 3 4]). You should also test to ensure that your code can still handle simple numeric assignments, like pi = 3.1415 without error.
  </p>
  
  <p>
    The next major hurdle will be implementing the new matrix operations, +, -, *, /, ==, and !=. You may wish to implement and test these one by one using a separate main() function that only constructs some sample matrices, performs the operations, and prints the results. You should be sure to test that the operations work as expected for both valid and invalid inputs.
  </p>
  
  <p>
    Finally, incorporate the new matrix operations by modifying the binary_assign_op and binary_op functions in your interpreter code. You can test these changes on the provided test file, as well as any cases that you used in testing the matrix operations in the previous step.
  </p>
  
  
  <h2> Bare bones .h files </h2>

  <pre>

cvariable.h
// value member variable - change to type CMatrix or CMatrix* rather than double

// new constructor
CVariable(const char* init_name, const CMatrix& init_value);  

// (modification)
CVariable(const char* init_name, double init_value);    

CMatrix& operator*();                   // REPLACE double& operator*()
CMatrix operator*() const;              // REPLACE double operator*() const

CMatrix& operator=(double newValue);    // (modification)
CMatrix& operator=(CMatrix& newValue);  // new function




cmatrix.h

CMatrix operator+(CMatrix& mat);
CMatrix operator-(CMatrix& mat);
CMatrix operator*(CMatrix& mat);
CMatrix operator/(CMatrix& mat);
bool operator==(CMatrix& mat); 
bool operator!=(CMatrix& mat);
  


  
main.cpp
// update interpreter function to handle CMatrix instead of double
// update helper functions like binary_assign_op and getValue to handle CMatrix instead of double

</pre>
  
</html>